{"meta":{"title":"ZHANGC'S BLOG","subtitle":null,"description":null,"author":"zhangcheng","url":"http://yoursite.com"},"pages":[{"title":"","date":"2016-12-12T06:38:05.547Z","updated":"2016-12-12T06:38:05.547Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"categories","date":"2016-12-12T03:03:49.000Z","updated":"2016-12-12T03:10:04.634Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2016-12-12T03:00:27.000Z","updated":"2016-12-12T03:01:21.006Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CommonJS，AMD，CMD区别","slug":"CommonJS，AMD，CMD区别","date":"2016-12-12T08:57:40.000Z","updated":"2016-12-12T09:00:16.750Z","comments":true,"path":"2016/12/12/CommonJS，AMD，CMD区别/","link":"","permalink":"http://yoursite.com/2016/12/12/CommonJS，AMD，CMD区别/","excerpt":"commonjs是用在服务器端的，同步的，如nodejsamd, cmd是用在浏览器端的，异步的，如requirejs和seajs其中，amd先提出，cmd是根据commonjs和amd基础上提出的。","text":"commonjs是用在服务器端的，同步的，如nodejsamd, cmd是用在浏览器端的，异步的，如requirejs和seajs其中，amd先提出，cmd是根据commonjs和amd基础上提出的。 CommonJSCommonJs 是服务器端模块的规范，Node.js采用了这个规范。 根据CommonJS规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。 例如：123456789101112131415161718192021222324// foobar.js //私有变量 var test = 123; //公有方法 function foobar () &#123; this.foo = function () &#123; // do someing ... &#125; this.bar = function () &#123; //do someing ... &#125; &#125; //exports对象上的方法和变量是公有的 var foobar = new foobar(); exports.foobar = foobar; //require方法默认读取js文件，所以可以省略js后缀 var test = require('./boobar').foobar; test.bar(); CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作。像Node.js主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以CommonJS规范比较适用。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD CMD 解决方案。 AMD(Asynchromous Module Definition)AMD 是 RequireJS 在推广过程中对模块定义的规范化产出 AMD异步加载模块。它的模块支持对象 函数 构造器 字符串 JSON等各种类型的模块。 适用AMD规范适用define方法定义模块。12345678910//通过数组引入依赖 ，回调函数通过形参传入依赖 define(['someModule1', ‘someModule2’], function (someModule1, someModule2) &#123; function foo () &#123; /// someing someModule1.test(); &#125; return &#123;foo: foo&#125; &#125;); AMD规范允许输出模块兼容CommonJS规范，这时define方法如下：123456789define(function (require, exports, module) &#123; var reqModule = require(\"./someModule\"); requModule.test(); exports.asplode = function () &#123; //someing &#125; &#125;); CMDCMD是SeaJS 在推广过程中对模块定义的规范化产出 CMD和AMD的区别有以下几点： 1.对于依赖的模块AMD是提前执行，CMD是延迟执行。不过RequireJS从2.0开始，也改成可以延迟执行（根据写法不同，处理方式不通过）。 2.CMD推崇依赖就近，AMD推崇依赖前置。1234567891011121314151617181920212223//AMD define(['./a','./b'], function (a, b) &#123; //依赖一开始就写好 a.test(); b.test(); &#125;); //CMD define(function (requie, exports, module) &#123; //依赖可以就近书写 var a = require('./a'); a.test(); ... //软依赖 if (status) &#123; var b = requie('./b'); b.test(); &#125; &#125;); 虽然 AMD也支持CMD写法，但依赖前置是官方文档的默认模块定义写法。 3.AMD的api默认是一个当多个用，CMD严格的区分推崇职责单一。例如：AMD里require分全局的和局部的。CMD里面没有全局的 require,提供 seajs.use()来实现模块系统的加载启动。CMD里每个API都简单纯粹。 SeaJS 和 RequireJS的主要区别 在此有解释","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript中的变量和函数声明提升","slug":"javascript中的变量和函数声明提升","date":"2016-12-08T09:06:37.000Z","updated":"2016-12-08T11:03:37.050Z","comments":true,"path":"2016/12/08/javascript中的变量和函数声明提升/","link":"","permalink":"http://yoursite.com/2016/12/08/javascript中的变量和函数声明提升/","excerpt":"在Javascript中，函数及变量的声明都将被提升到函数的最顶部。声明函数是将函数的声明以及定义都提升，函数表达式和变量表达式只是将函数或者变量的声明提升到函数顶部，而函数表达式和变量的初始化将不被提升，如果不弄清楚这个问题，很可能在工作中带来麻烦。","text":"在Javascript中，函数及变量的声明都将被提升到函数的最顶部。声明函数是将函数的声明以及定义都提升，函数表达式和变量表达式只是将函数或者变量的声明提升到函数顶部，而函数表达式和变量的初始化将不被提升，如果不弄清楚这个问题，很可能在工作中带来麻烦。 变量声明提升变量作用域变量作用域指变量起作用的范围。变量分为全局变量和局部变量。全局变量在全局都拥有定义；而局部变量只能在函数体内有效,函数参数也是局部变量。在函数体内，同名的局部变量或者参数的优先级会高于全局变量。也就是说，如果函数内的局部变量或者参数和全局变量同名，那么全局变量将会被局部变量覆盖。所有不使用var定义的变量都视为全局变量 函数作用域和声明提前JavaScript使用函数作用域:变量在声明它们的函数体内以及这个函数嵌套的任意函数体内都是有定义的;JavaScript的函数作用是指在函数内声明的所有变量在函数体内始终是有定义的，也就是说变量在声明之前已经可用，所有这特性称为声明提前（hoisting），即JavaScript函数里的所有声明（只是声明，但不涉及赋值）都被提前到函数体的顶部，而变量赋值操作留在原来的位置。注释：声明提前是在JavaScript引擎的预编译时进行，是在代码开始运行之前。如下面例子：123456var scope = 'global';function f()&#123; console.log(scope); //输出undefined 而不是 global var scope = 'local'; console.log(scope); //输出local&#125; 由于函数内声明提升，所以上面的代码实际上是这样的1234567var scope = 'global';function f()&#123; var scope; //变量声明提升到函数顶部 console.log(scope); scope = 'local'; //变量初始化依然保留在原来的位置 console.log(scope);&#125; 经过这样变形之后，答案就就非常明显了。由于scope在第一个console.log(scope)语句之前就已经定义了，但是并没有赋值，因此此时scope的指是undefined.第二个console.log(scope)语句之前，scope已经完成赋值为’local’，所以输出的结果是local。 函数声明提升函数的两种创建方式 函数声明语法 1234f('zhangc');function f(name)&#123; console.log(name);&#125; 运行上面的程序，控制台能打印出zhangc。 函数表达式语法(产生副作用) 1234f('zhangc');var f = function(name)&#123; console.log(name);&#125; 运行上面的代码，会报错Uncaught ReferenceError: f is not defined(…),错误信息显示说f没有被定义。为什么同样的代码，函数声明和函数表达式存在着差异呢？这是因为，函数声明有一个非常重要的特征：函数声明提升，函数声明语句将会被提升到外部脚本或者外部函数作用域的顶部（是不是跟变量提升非常类似）。函数声明语句中的函数名是一个变量名,变量指向函数对象,和通过var声明变量一样,函数声明语句中的函数被显示地”提前”到了脚本或者函数的顶部,因此它们在整个脚本和函数内部是可见的.正是因为这个特征，所以可以把函数声明放在调用它的语句后面。如下面例子，最终的输出结果应该是什么？： 1234567var getName = function()&#123; console.log(2);&#125;function getName ()&#123; console.log(1);&#125;getName(); 可能会有人觉得最后输出的结果是1。让我们来分析一下，这个例子涉及到了变量声明提升和函数声明提升。正如前面说到的函数声明提升，函数声明function getName(){}的声明会被提前到顶部。而函数表达式var getName = function(){}则表现出变量声明提升。因此在这种情况下，getName也是一个变量，因此这个变量的声明也将提升到顶部部，而变量的赋值依然保留在原来的位置。因此上面的函数可以转换成下面的样子: 12345678var getName; //变量声明提升function getName()&#123; //函数声明提升到顶部 console.log(1);&#125;getName = function()&#123; //变量赋值依然保留在原来的位置 console.log(2);&#125;getName(); // 最终输出：2 所以最终的输出结果是：2。在原来的例子中，函数声明虽然是在函数表达式后面，但由于函数声明提升到顶部，因此后面getName又被函数表达式的赋值操作给覆盖了，所以输出2。 结论 使用函数表达式语句即通过var定义函数),只有变量声明提前了–变量的初始化代码仍然在原来的位置;使用函数声明语句,函数名称和函数体均被提前; 变量声明提升：变量申明在进入执行上下文就完成了。只要变量在代码中进行了声明，无论它在哪个位置上进行声明， js引擎都会将它的声明放在范围作用域的顶部； 函数声明提升：执行代码之前会先读取函数声明，意味着可以把函数申明放在调用它的语句后面。只要函数在代码中进行了声明，无论它在哪个位置上进行声明， js引擎都会将它的声明放在范围作用域的顶部；可以在声明javaScript函数之前调用它; 变量or函数声明：函数声明会覆盖变量声明，但不会覆盖变量赋值。同一个名称标识a，即有变量声明var a，又有函数声明function a() {}，不管二者声明的顺序，函数声明会覆盖变量声明，也就是说，此时a的值是声明的函数function a() {}。注意：如果在变量声明的同时初始化a，或是之后对a进行赋值， 一个完整的例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;html&gt;&lt;head&gt;&lt;title&gt;函数提升&lt;/title&gt;&lt;script language=\"javascript\" type=\"text/javascript\"&gt; //在全局对象中声明两个全局函数,反模式 function foo()&#123; alert(\"global foo\"); &#125; function bar()&#123; alert(\"global bar\"); &#125; //定义全局变量 var v = \"global var\"; function hoistMe()&#123; alert(typeof foo); //function alert(typeof bar); //undefined alert(v); //undefined //为什么bar函数和变量v是未定义而不是全局变量中定义的相应的函数变量呢？ //因为函数里面定义了同名的函数和变量，无论在函数的任何位置定义这些函数和 //和变量，它们都将被提升到函数的最顶部。 foo(); //local foo bar(); //报错，缺少对象 //函数声明，变量foo以及其实现被提升到hoistMe函数顶部 function foo() &#123; alert(\"local foo\"); &#125; //函数表达式,仅变量bar被提升到函数顶部，实现没有被提升 var bar = function() &#123; alert(\"local bar\"); &#125;; //定义局部变量 var v = \"local\"; &#125; (function()&#123; hoistMe(); &#125;)(); //函数表达式和变量表达式只是其声明被提升，函数声明是函数的声明和实现都被提升。 /**由于函数提升的效果，hoistMe方法相当于 function hoistMe()&#123; //函数声明，变量foo以及其实现被提升到hoistMe函数顶部 function foo()&#123; alert(\"local foo\"); &#125; //函数表达式,仅变量bar被提升到函数顶部，实现没有被提升(同变量提升) var bar = undefined; //变量声明被提升 var v = undefined; alert(typeof foo); //function alert(typeof bar); //undefined foo(); //local foo bar(); //报错，缺少对象 bar = function()&#123; alert(\"local bar\"); &#125;; v = \"local\"; &#125; */&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 内容整理自互联网","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javaScript方法整理","slug":"javascript方法整理","date":"2016-12-07T13:31:40.000Z","updated":"2016-12-13T04:56:19.373Z","comments":true,"path":"2016/12/07/javascript方法整理/","link":"","permalink":"http://yoursite.com/2016/12/07/javascript方法整理/","excerpt":"搜索框效果1234567891011121314151617181920/*** @param inputName：文本框id* @param searchObj：搜索的UL的id*/function searchName(inputName, searchObj) &#123; $(\"#\" + inputName).on(\"input propertychange\", function () &#123; var inputVal = $(\"#\" + inputName).val(); if (inputVal != \"\") &#123; var searchObjLength = $(\"#\" + searchObj + \"&gt;li\").length; $(\"#\" + searchObj + \"&gt;li\").addClass(\"hide\"); for (var i = 0; i &lt; searchObjLength; i++) &#123; if (($(\"#\" + searchObj + \"&gt;li\").eq(i).text().toLowerCase()).indexOf(inputVal.toLowerCase()) != -1) &#123; $(\"#\" + searchObj + \"&gt;li\").eq(i).removeClass(\"hide\"); &#125; &#125; &#125; else &#123; $(\"#\" + searchObj + \"&gt;li\").removeClass(\"hide\"); &#125; &#125;);&#125;","text":"搜索框效果1234567891011121314151617181920/*** @param inputName：文本框id* @param searchObj：搜索的UL的id*/function searchName(inputName, searchObj) &#123; $(\"#\" + inputName).on(\"input propertychange\", function () &#123; var inputVal = $(\"#\" + inputName).val(); if (inputVal != \"\") &#123; var searchObjLength = $(\"#\" + searchObj + \"&gt;li\").length; $(\"#\" + searchObj + \"&gt;li\").addClass(\"hide\"); for (var i = 0; i &lt; searchObjLength; i++) &#123; if (($(\"#\" + searchObj + \"&gt;li\").eq(i).text().toLowerCase()).indexOf(inputVal.toLowerCase()) != -1) &#123; $(\"#\" + searchObj + \"&gt;li\").eq(i).removeClass(\"hide\"); &#125; &#125; &#125; else &#123; $(\"#\" + searchObj + \"&gt;li\").removeClass(\"hide\"); &#125; &#125;);&#125; 上移下移12345678910111213141516$(\"#key_group_model_warp .table_td_text1_move_up_a\").on(\"click\",function() &#123; var $tr = $(this).parent().parent(); $tr.prev().before($tr); resetKeyGroupTrStyle();&#125;);$(\"#key_group_model_warp .table_td_text1_move_down_a\").on(\"click\",function() &#123; var $tr = $(this).parent().parent(\"tr\"); $tr.next().after($tr); resetKeyGroupTrStyle();&#125;);function resetKeyGroupTrStyle() &#123; var tr_count = $(\"#key_group_model_warp tr\").length; $(\"#key_group_model_warp tr\").find(\"a\").css(&#123;\"color\": \"#337ab7\",\"pointer-events\": \"auto\"&#125;); $(\"#key_group_model_warp tr\").eq(0).find(\"a\").eq(1).css(&#123;\"color\": \"#ddd\",\"pointer-events\": \"none\"&#125;); $(\"#key_group_model_warp tr\").eq(tr_count).find(\"a\").eq(2).css(&#123;\"color\": \"#ddd\", \"pointer-events\": \"none\"&#125;);&#125;​ ​ 截取文件名称12345678910function getUploadFileName(filepath)&#123; var pos; var regExp = /[a-zA-z]+:\\\\[^\\s]*/; if(regExp.test(filepath))&#123; pos = filepath.lastIndexOf(\"\\\\\"); &#125;else&#123; pos = filepath.lastIndexOf(\"/\"); &#125; return filepath.substring(pos + 1);&#125; 时间检查函数1234567891011121314151617181920/** * 时间检查函数 */ function cpDayReport_timeCheck(timeBegin,timeEnd) &#123; var begin = Date.parse(timeBegin.replace(/-/g,\"/\")); var end = Date.parse(timeEnd.replace(/-/g,\"/\")); var now = Date.parse(new Date().toDateString()); if(begin &gt;= now) &#123; Box.alert(\"开始日期必须小于当前日期!\"); return -1; &#125; else if(end &gt;= now) &#123; Box.alert(\"结束日期必须小于当前日期!\"); return -2; &#125; else if(begin &gt; end) &#123; Box.alert(\"开始日期必须小于结束日期!\"); return -3; &#125; else &#123; return 1; &#125; &#125; ​","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"Markdown语法","slug":"Markdown语法","date":"2016-12-07T12:59:00.000Z","updated":"2016-12-12T02:55:12.169Z","comments":true,"path":"2016/12/07/Markdown语法/","link":"","permalink":"http://yoursite.com/2016/12/07/Markdown语法/","excerpt":"什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档;","text":"什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档; 『Cmd 技术渲染的沙箱页面，点击此处编写自己的文档』 Cmd Markdown 简明语法手册标签： Cmd-Markdown 1. 斜体和粗体使用 和 * 表示斜体和粗体。 示例： 这是 斜体，这是 粗体。 2. 分级标题使用 === 表示一级标题，使用 — 表示二级标题。 示例： 1234567这是一个一级标题============================这是一个二级标题--------------------------------------------------### 这是一个三级标题 你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。 3. 外链接使用 [描述](链接地址) 为文字增加外链接。 示例： 这是去往 本人博客 的链接。 4. 无序列表使用 *，+，- 表示无序列表。 示例： 无序列表项 一 无序列表项 二 无序列表项 三 5. 有序列表使用数字和点表示有序列表。 示例： 有序列表项 一 有序列表项 二 有序列表项 三 6. 文字引用使用 &gt; 表示文字引用。 示例： 野火烧不尽，春风吹又生。 7. 行内代码块使用 `代码` 表示行内代码块。 示例： 让我们聊聊 html。 8. 代码块使用 四个缩进空格 表示代码块。 示例： 这是一个代码块，此行左侧有四个不可见的空格。 9. 插入图像使用 ![描述](图片链接地址) 插入图像。 示例： Cmd Markdown 高阶语法手册1. 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。 [TOC] 2. 标签分类在编辑区任意行的列首位置输入以下代码给文稿标签： 标签： 数学 英语 Markdown 或者 Tags： 数学 英语 Markdown 3. 删除线使用 ~~ 表示删除线。 这是一段错误的文本。 4. 注脚使用 [^keyword] 表示注脚。 这是一个注脚[^footnote]的样例。 这是第二个注脚[^footnote2]的样例。 5. LaTeX 公式$ 表示行内公式： 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 $$ 表示整行公式： $$\\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ $$\\sum^{j-1}{k=0}{\\widehat{\\gamma}{kj} z_k}$$ 访问 MathJax 参考更多使用方法。 6. 加强的代码块支持四十一种编程语言的语法高亮的显示，行号显示。 非代码示例： 1$ sudo apt-get install vim-gnome Python 示例： 123456789101112@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' JavaScript 示例： 1234567891011121314151617/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10)); 7. 流程图示例12345678910st=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 更多语法参考：流程图语法参考8. 序列图示例 1123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 示例 212345Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow 更多语法参考：序列图语法参考9. 甘特图甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。 12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 更多语法参考：甘特图语法参考10. Mermaid 流程图1234A[Hard edge] --&gt;|Link text| B(Round edge)B --&gt; C&#123;Decision&#125;C --&gt;|One| D[Result one]C --&gt;|Two| E[Result two] 更多语法参考：Mermaid 流程图语法参考11. Mermaid 序列图1234Alice-&gt;John: Hello John, how are you?loop every minute John--&gt;Alice: Great!end 更多语法参考：Mermaid 序列图语法参考12. 表格支持 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234 13. 定义型列表名词 1: 定义 1（左侧有一个可见的冒号和四个不可见的空格） 代码块 2: 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 14. Html 标签本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格： &lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 值班人员 星期一 星期二 星期三 李强 张明 王平 15. 内嵌图标本站的图标系统对外开放，在文档中输入 &lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt; 即显示微博的图标： 替换 上述 i 标签 内的 icon-weibo 以显示不同的图标，例如： &lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt; 即显示人人的图标： 更多的图标和玩法可以参看 font-awesome 官方网站。 16. 待办事宜 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如： - [ ] **Cmd Markdown 开发** - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 - [ ] 支持以 PDF 格式导出文稿 - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments) - [x] 改进 LaTex 功能 - [x] 修复 LaTex 公式渲染问题 - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers) - [ ] **七月旅行准备** - [ ] 准备邮轮上需要携带的物品 - [ ] 浏览日本免税店的物品 - [x] 购买蓝宝石公主号七月一日的船票 对应显示如下待办事宜 Todo 列表： [ ] Cmd Markdown 开发 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [ ] 支持以 PDF 格式导出文稿 [x] 新增Todo列表功能 语法参考 [x] 改进 LaTex 功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 语法参考 [ ] 七月旅行准备 [ ] 准备邮轮上需要携带的物品 [ ] 浏览日本免税店的物品 [x] 购买蓝宝石公主号七月一日的船票 [^footnote]: 这是一个 注脚 的 文本。 [^footnote2]: 这是另一个 注脚 的 文本。 转自Cmd Markdown","categories":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/categories/blog/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"},{"name":"文章","slug":"文章","permalink":"http://yoursite.com/tags/文章/"}]}]}